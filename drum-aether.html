<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Drum Aether</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Instrument+Serif:ital@0;1&family=DM+Mono:wght@300;400&display=swap');

  :root {
    --bg: #0a0a0f;
    --surface: #12121a;
    --accent: #ff8800;
    --accent2: #ff3366;
    --accent3: #7b61ff;
    --text: #e8e8f0;
    --text-dim: #555568;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Mono', monospace;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 20px 32px;
    border-bottom: 1px solid rgba(255,255,255,0.04);
    z-index: 10;
  }

  .logo {
    font-family: 'Instrument Serif', serif;
    font-size: 28px;
    font-style: italic;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .logo-tag {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.2em;
    color: var(--accent);
    margin-left: 10px;
    opacity: 0.6;
  }

  .status {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--text-dim);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-dot {
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--text-dim); transition: background 0.3s;
  }

  .status-dot.active { background: var(--accent); box-shadow: 0 0 8px var(--accent); }

  .main-area { flex: 1; display: flex; position: relative; overflow: hidden; }

  .video-container {
    position: relative; flex: 1; display: flex;
    align-items: center; justify-content: center;
  }

  video, .overlay-canvas {
    position: absolute; width: 100%; height: 100%; object-fit: cover;
  }

  video { transform: scaleX(-1); opacity: 0.25; filter: grayscale(0.6) contrast(1.1); }
  .overlay-canvas { transform: scaleX(-1); z-index: 2; }

  .viz-canvas {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 1; pointer-events: none;
  }

  .hit-flash {
    position: absolute; inset: 0; z-index: 3; pointer-events: none;
    background: radial-gradient(ellipse at center, rgba(255,136,0,0.3), transparent 70%);
    opacity: 0; transition: opacity 0.06s ease-out;
  }

  .start-overlay {
    position: absolute; inset: 0; z-index: 20;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    background: rgba(10,10,15,0.92); backdrop-filter: blur(20px);
    transition: opacity 0.6s ease, visibility 0.6s;
  }

  .start-overlay.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

  .start-title {
    font-family: 'Instrument Serif', serif; font-style: italic;
    font-size: clamp(48px, 8vw, 96px);
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    margin-bottom: 16px;
  }

  .start-sub {
    font-size: 13px; color: var(--text-dim);
    letter-spacing: 0.12em; text-transform: uppercase; margin-bottom: 48px;
  }

  .start-btn {
    background: none; border: 1px solid rgba(255,255,255,0.12);
    color: var(--text); font-family: 'DM Mono', monospace;
    font-size: 13px; letter-spacing: 0.15em; text-transform: uppercase;
    padding: 16px 48px; cursor: pointer; transition: all 0.3s;
  }

  .start-btn:hover { border-color: var(--accent); color: var(--accent); }

  /* Side panel */
  .side-panel {
    width: 280px; background: var(--surface);
    border-left: 1px solid rgba(255,255,255,0.04);
    padding: 24px; display: flex; flex-direction: column; gap: 18px;
    z-index: 5; overflow-y: auto;
  }

  .panel-section h3 {
    font-size: 10px; text-transform: uppercase;
    letter-spacing: 0.2em; color: var(--text-dim); margin-bottom: 10px;
  }

  .param-row {
    display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;
  }

  .param-label { font-size: 12px; color: var(--text-dim); }

  .param-value {
    font-size: 12px; color: var(--accent);
    font-variant-numeric: tabular-nums; min-width: 60px; text-align: right;
  }

  .meter-bar {
    width: 100%; height: 3px; background: rgba(255,255,255,0.04);
    border-radius: 2px; margin-top: 3px; overflow: hidden;
  }

  .meter-fill {
    height: 100%; border-radius: 2px; transition: width 0.1s ease-out;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
  }

  .selector-grid { display: flex; flex-wrap: wrap; gap: 6px; }

  .sel-btn {
    font-family: 'DM Mono', monospace; font-size: 11px; padding: 6px 12px;
    border: 1px solid rgba(255,255,255,0.06); background: none;
    color: var(--text-dim); cursor: pointer; transition: all 0.2s;
  }

  .sel-btn.active { border-color: var(--accent); color: var(--accent); background: rgba(255,136,0,0.05); }
  .sel-btn:hover:not(.active) { border-color: rgba(255,255,255,0.15); color: var(--text); }

  .instructions { font-size: 11px; line-height: 1.7; color: var(--text-dim); }
  .instructions em { color: var(--accent); font-style: normal; }
  .instructions .dim-em { color: var(--accent3); font-style: normal; }

  .drum-display {
    position: absolute; bottom: 24px; left: 50%; transform: translateX(-50%);
    z-index: 10; text-align: center; pointer-events: none;
  }

  .current-drum {
    font-family: 'Instrument Serif', serif; font-style: italic; font-size: 72px;
    color: var(--accent); text-shadow: 0 0 40px rgba(255,136,0,0.3);
    opacity: 0; transition: opacity 0.12s;
  }

  .current-drum.visible { opacity: 1; }

  .drum-sub {
    font-size: 11px; color: var(--text-dim);
    letter-spacing: 0.1em; text-transform: uppercase; margin-top: 4px;
  }

  .volume-row { display: flex; align-items: center; gap: 10px; }

  .volume-slider {
    -webkit-appearance: none; appearance: none;
    flex: 1; height: 3px; background: rgba(255,255,255,0.08);
    border-radius: 2px; outline: none;
  }
  .volume-slider::-webkit-slider-thumb {
    -webkit-appearance: none; width: 12px; height: 12px;
    border-radius: 50%; background: var(--accent); cursor: pointer;
  }
  .volume-pct { font-size: 11px; color: var(--accent); min-width: 36px; text-align: right; }

  /* Zone map display */
  .zone-map {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 3px;
    font-size: 10px;
  }

  .zone-map-item {
    padding: 4px 6px;
    border-radius: 3px;
    text-align: center;
    border: 1px solid rgba(255,255,255,0.06);
    color: var(--text-dim);
    transition: all 0.15s;
  }

  .zone-map-item.hit {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(255,136,0,0.1);
  }

  .grain-overlay {
    position: fixed; inset: 0; pointer-events: none; z-index: 100; opacity: 0.03;
    background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
  }

  .sensitivity-row { display: flex; align-items: center; gap: 10px; margin-top: 6px; }
  .sensitivity-slider {
    -webkit-appearance: none; appearance: none;
    flex: 1; height: 3px; background: rgba(255,255,255,0.08);
    border-radius: 2px; outline: none;
  }
  .sensitivity-slider::-webkit-slider-thumb {
    -webkit-appearance: none; width: 12px; height: 12px;
    border-radius: 50%; background: var(--accent3); cursor: pointer;
  }
  .sensitivity-val { font-size: 11px; color: var(--accent3); min-width: 36px; text-align: right; }

  @keyframes zone-pulse {
    0% { opacity: 0.7; }
    100% { opacity: 0; }
  }
</style>
</head>
<body>

<header>
  <div style="display:flex;align-items:baseline;">
    <div class="logo">Drum Aether</div>
    <span class="logo-tag">Air Drums</span>
  </div>
  <div class="status" id="statusBar">
    <span class="status-dot" id="statusDot"></span>
    <span id="statusText">waiting</span>
  </div>
</header>

<div class="main-area">
  <div class="video-container">
    <video id="video" playsinline></video>
    <canvas class="overlay-canvas" id="canvas"></canvas>
    <canvas class="viz-canvas" id="vizCanvas"></canvas>
    <div class="hit-flash" id="hitFlash"></div>

    <div class="drum-display">
      <div class="current-drum" id="currentDrum"></div>
      <div class="drum-sub" id="drumSub"></div>
    </div>

    <div class="start-overlay" id="startOverlay">
      <div class="start-title">Drum Aether</div>
      <div class="start-sub">Air drumming with hand tracking</div>
      <button class="start-btn" id="startBtn">Begin</button>
    </div>
  </div>

  <div class="side-panel">
    <div class="panel-section">
      <h3>Kit</h3>
      <div class="selector-grid" id="kitSelector"></div>
    </div>

    <div class="panel-section">
      <h3>Volume</h3>
      <div class="volume-row">
        <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="70">
        <span class="volume-pct" id="volumePct">70%</span>
      </div>
    </div>

    <div class="panel-section">
      <h3>Sensitivity</h3>
      <div class="sensitivity-row">
        <input type="range" class="sensitivity-slider" id="sensitivitySlider" min="10" max="90" value="40">
        <span class="sensitivity-val" id="sensitivityVal">40</span>
      </div>
    </div>

    <div class="panel-section">
      <h3>Tracking</h3>
      <div class="param-row"><span class="param-label">Left hand</span><span class="param-value" id="leftZone">—</span></div>
      <div class="param-row"><span class="param-label">Right hand</span><span class="param-value" id="rightZone">—</span></div>
      <div class="param-row"><span class="param-label">Last hit</span><span class="param-value" id="lastHit">—</span></div>
      <div class="param-row">
        <span class="param-label">Velocity</span>
        <span class="param-value" id="velocityVal">—</span>
      </div>
      <div class="meter-bar"><div class="meter-fill" id="velocityMeter" style="width:0%"></div></div>
    </div>

    <div class="panel-section">
      <h3>Drum Map</h3>
      <div class="zone-map" id="zoneMap"></div>
    </div>

    <div class="panel-section">
      <h3>How to Play</h3>
      <div class="instructions">
        <em>Strike down</em> — move hand down quickly to hit<br>
        <em>Zone position</em> — where your hand is selects the drum<br>
        <span class="dim-em">Open hand</span> in hi-hat zone → open hi-hat<br>
        <span class="dim-em">Closed fist</span> in hi-hat zone → closed hi-hat<br><br>
        Layout (your perspective):<br>
        Top: <em>Crash · Splash · Ride</em><br>
        Mid: <em>HH · HiTom · MidTom · FlTom</em><br>
        Bot: <em>Snare · Kick</em>
      </div>
    </div>
  </div>
</div>

<div class="grain-overlay"></div>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<script>
(function() {
  'use strict';

  // =========================================================
  //  DRUM ZONES — arranged like a real kit (player's view)
  //  Coordinates use screenX (1 - landmark.x) so left = player's left
  // =========================================================
  const DRUM_ZONES = [
    // Top row — Cymbals
    { id: 'crash',   label: 'Crash',    x1: 0.00, y1: 0.00, x2: 0.33, y2: 0.28, color: '#FFD700' },
    { id: 'splash',  label: 'Splash',   x1: 0.33, y1: 0.00, x2: 0.66, y2: 0.25, color: '#F5DEB3' },
    { id: 'ride',    label: 'Ride',     x1: 0.66, y1: 0.00, x2: 1.00, y2: 0.28, color: '#DA70D6' },
    // Middle row — Hi-hat + Toms
    { id: 'hihat',   label: 'Hi-Hat',   x1: 0.00, y1: 0.28, x2: 0.22, y2: 0.60, color: '#87CEEB' },
    { id: 'tom-hi',  label: 'Hi Tom',   x1: 0.22, y1: 0.25, x2: 0.44, y2: 0.56, color: '#98FB98' },
    { id: 'tom-mid', label: 'Mid Tom',  x1: 0.44, y1: 0.25, x2: 0.66, y2: 0.56, color: '#DDA0DD' },
    { id: 'tom-floor', label: 'Fl Tom', x1: 0.66, y1: 0.28, x2: 1.00, y2: 0.60, color: '#20B2AA' },
    // Bottom row — Snare + Kick
    { id: 'snare',   label: 'Snare',    x1: 0.00, y1: 0.60, x2: 0.45, y2: 1.00, color: '#FF6B6B' },
    { id: 'kick',    label: 'Kick',     x1: 0.45, y1: 0.60, x2: 1.00, y2: 1.00, color: '#FF8C00' },
  ];

  // =========================================================
  //  KIT DEFINITIONS — sample-based drums from Tone.js CDN
  // =========================================================
  const SAMPLE_BASE = 'https://tonejs.github.io/audio/drum-samples/';

  const KITS = {
    acoustic:  { folder: 'acoustic-kit', name: 'Acoustic' },
    breakbeat: { folder: 'breakbeat8',   name: 'Breakbeat' },
    cr78:      { folder: 'CR78',         name: 'CR-78' },
    techno:    { folder: 'Techno',       name: 'Techno' },
    kit8:      { folder: 'Kit8',         name: 'Kit 8' },
    linn:      { folder: 'LINN',         name: 'Linn' },
  };

  // Sample drums: loaded from CDN per kit (kick, snare, hihat, tom1-3)
  // Synth drums: crash, ride, splash, open hi-hat (MetalSynth)

  // =========================================================
  //  STATE
  // =========================================================
  let currentKit = 'acoustic';
  let masterGain = 0.7;
  let sensitivity = 0.04; // strike velocity threshold
  let samplesLoaded = false;

  // Audio nodes
  let drumPlayers = {};    // Tone.Player per sample drum
  let synthDrums = {};     // MetalSynth for cymbals
  let reverbNode = null;
  let gainNode = null;

  // Per-hand tracking
  const handTrack = {
    Left:  { prevY: null, canStrike: true, cooldown: 0, zone: null },
    Right: { prevY: null, canStrike: true, cooldown: 0, zone: null },
  };

  // Visual state
  let lastHitDrum = null;
  let lastHitTime = 0;
  let hitFlashTimer = null;
  let zoneFlashes = {};  // zone id → timestamp of last hit

  // DOM refs
  const video = document.getElementById('video');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const vizCanvas = document.getElementById('vizCanvas');
  const vizCtx = vizCanvas.getContext('2d');
  const startOverlay = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const statusDot = document.getElementById('statusDot');
  const statusText = document.getElementById('statusText');
  const statusBar = document.getElementById('statusBar');
  const hitFlash = document.getElementById('hitFlash');
  const currentDrumEl = document.getElementById('currentDrum');
  const drumSubEl = document.getElementById('drumSub');
  const kitSelector = document.getElementById('kitSelector');
  const volumeSlider = document.getElementById('volumeSlider');
  const volumePct = document.getElementById('volumePct');
  const sensitivitySlider = document.getElementById('sensitivitySlider');
  const sensitivityVal = document.getElementById('sensitivityVal');
  const leftZoneEl = document.getElementById('leftZone');
  const rightZoneEl = document.getElementById('rightZone');
  const lastHitEl = document.getElementById('lastHit');
  const velocityValEl = document.getElementById('velocityVal');
  const velocityMeter = document.getElementById('velocityMeter');
  const zoneMapEl = document.getElementById('zoneMap');

  function lerp(a, b, t) { return a + (b - a) * t; }

  // =========================================================
  //  AUDIO SETUP
  // =========================================================
  function initAudio() {
    reverbNode = new Tone.Reverb({ decay: 1.5, wet: 0.12 }).toDestination();
    gainNode = new Tone.Gain(masterGain).connect(reverbNode);
  }

  async function loadKit(kitId) {
    samplesLoaded = false;
    statusText.textContent = 'loading ' + KITS[kitId].name + '...';

    // Dispose old players
    Object.values(drumPlayers).forEach(p => { try { p.dispose(); } catch(e) {} });
    drumPlayers = {};

    const folder = KITS[kitId].folder;
    const baseUrl = SAMPLE_BASE + folder + '/';

    // Sample mappings: zone id → filename
    const sampleMap = {
      'kick':    'kick.mp3',
      'snare':   'snare.mp3',
      'hihat':   'hihat.mp3',
      'tom-hi':  'tom1.mp3',
      'tom-mid': 'tom2.mp3',
      'tom-floor': 'tom3.mp3',
    };

    const loadPromises = [];

    for (const [drumId, filename] of Object.entries(sampleMap)) {
      const p = new Promise((resolve) => {
        const player = new Tone.Player({
          url: baseUrl + filename,
          onload: () => resolve(true),
          onerror: () => {
            console.warn('Failed to load ' + drumId + ' from ' + baseUrl + filename);
            resolve(false);
          }
        }).connect(gainNode);
        drumPlayers[drumId] = player;
      });
      loadPromises.push(p);
    }

    // Create synth drums for cymbals (if not already created)
    if (!synthDrums.crash) {
      synthDrums.crash = new Tone.MetalSynth({
        frequency: 300,
        envelope: { attack: 0.001, decay: 1.4, release: 0.2 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 4000,
        octaves: 1.5,
        volume: -10,
      }).connect(gainNode);

      synthDrums.ride = new Tone.MetalSynth({
        frequency: 400,
        envelope: { attack: 0.001, decay: 0.8, release: 0.1 },
        harmonicity: 5.1,
        modulationIndex: 20,
        resonance: 5000,
        octaves: 1.0,
        volume: -12,
      }).connect(gainNode);

      synthDrums.splash = new Tone.MetalSynth({
        frequency: 350,
        envelope: { attack: 0.001, decay: 0.5, release: 0.08 },
        harmonicity: 5.1,
        modulationIndex: 28,
        resonance: 4500,
        octaves: 1.2,
        volume: -11,
      }).connect(gainNode);

      synthDrums['hihat-open'] = new Tone.MetalSynth({
        frequency: 250,
        envelope: { attack: 0.001, decay: 0.35, release: 0.08 },
        harmonicity: 5.1,
        modulationIndex: 40,
        resonance: 6000,
        octaves: 0.5,
        volume: -14,
      }).connect(gainNode);
    }

    await Promise.all(loadPromises);
    samplesLoaded = true;
    currentKit = kitId;
    statusText.textContent = 'tracking';
    updateKitButtons();
  }

  function triggerDrum(drumId, velocity, isOpenHihat) {
    if (!samplesLoaded && !synthDrums[drumId]) return;

    const vol = Tone.gainToDb(velocity * masterGain);
    const now = Tone.now();

    // Hi-hat zone: open vs closed
    if (drumId === 'hihat') {
      if (isOpenHihat) {
        synthDrums['hihat-open'].volume.value = vol + 2;
        synthDrums['hihat-open'].triggerAttackRelease('C1', 0.3, now);
      } else {
        const player = drumPlayers['hihat'];
        if (player && player.loaded) {
          player.volume.value = vol;
          player.stop(now);
          player.start(now);
        }
      }
    }
    // Synth-based cymbals
    else if (synthDrums[drumId]) {
      synthDrums[drumId].volume.value = vol;
      synthDrums[drumId].triggerAttackRelease('C1', drumId === 'crash' ? 1.0 : 0.4, now);
    }
    // Sample-based drums
    else if (drumPlayers[drumId] && drumPlayers[drumId].loaded) {
      drumPlayers[drumId].volume.value = vol;
      drumPlayers[drumId].stop(now);
      drumPlayers[drumId].start(now);
    }

    // Visual feedback
    showHit(drumId, velocity);
  }

  // =========================================================
  //  VISUAL FEEDBACK
  // =========================================================
  function showHit(drumId, velocity) {
    const zone = DRUM_ZONES.find(z => z.id === drumId);
    if (!zone) return;

    lastHitDrum = zone.label;
    lastHitTime = performance.now();
    zoneFlashes[drumId] = performance.now();

    // Flash overlay
    hitFlash.style.opacity = Math.min(0.6, velocity * 0.8);
    clearTimeout(hitFlashTimer);
    hitFlashTimer = setTimeout(() => { hitFlash.style.opacity = 0; }, 80);

    // Big drum name display
    currentDrumEl.textContent = zone.label;
    currentDrumEl.classList.add('visible');
    clearTimeout(currentDrumEl._timer);
    currentDrumEl._timer = setTimeout(() => {
      currentDrumEl.classList.remove('visible');
    }, 400);

    // Update panel
    lastHitEl.textContent = zone.label;
    velocityValEl.textContent = (velocity * 100).toFixed(0) + '%';
    velocityMeter.style.width = (velocity * 100) + '%';

    // Update zone map
    updateZoneMap(drumId);
  }

  function updateZoneMap(hitId) {
    const items = zoneMapEl.querySelectorAll('.zone-map-item');
    items.forEach(item => {
      if (item.dataset.id === hitId) {
        item.classList.add('hit');
        clearTimeout(item._timer);
        item._timer = setTimeout(() => item.classList.remove('hit'), 300);
      }
    });
  }

  // =========================================================
  //  ZONE DETECTION
  // =========================================================
  function getZoneAtPosition(screenX, screenY) {
    for (const zone of DRUM_ZONES) {
      if (screenX >= zone.x1 && screenX <= zone.x2 &&
          screenY >= zone.y1 && screenY <= zone.y2) {
        return zone;
      }
    }
    return null;
  }

  // =========================================================
  //  FINGER STATE DETECTION (for hi-hat open/closed)
  // =========================================================
  function countExtendedFingers(landmarks) {
    let count = 0;
    // Index finger: tip (8) vs PIP (6)
    if (landmarks[8].y < landmarks[6].y) count++;
    // Middle finger: tip (12) vs PIP (10)
    if (landmarks[12].y < landmarks[10].y) count++;
    // Ring finger: tip (16) vs PIP (14)
    if (landmarks[16].y < landmarks[14].y) count++;
    // Pinky: tip (20) vs PIP (18)
    if (landmarks[20].y < landmarks[18].y) count++;
    return count;
  }

  // =========================================================
  //  STRIKE DETECTION
  // =========================================================
  function detectStrike(handLabel, wristY) {
    const state = handTrack[handLabel];
    if (!state) return null;

    if (state.prevY === null) {
      state.prevY = wristY;
      return null;
    }

    // Velocity = change in Y (positive = moving downward in screen space)
    const velocity = wristY - state.prevY;
    state.prevY = wristY;

    // Cooldown
    if (state.cooldown > 0) {
      state.cooldown--;
      // Allow new strike once hand moves back up
      if (velocity < -0.005) state.canStrike = true;
      return null;
    }

    // Detect downward strike
    if (velocity > sensitivity && state.canStrike) {
      state.canStrike = false;
      state.cooldown = 4; // ~4 frames cooldown

      // Map velocity to hit strength (0.2 to 1.0)
      const hitVelocity = Math.min(1.0, Math.max(0.2, (velocity - sensitivity) * 12 + 0.3));
      return hitVelocity;
    }

    // Reset when moving up
    if (velocity < -0.008) {
      state.canStrike = true;
    }

    return null;
  }

  // =========================================================
  //  DRAWING
  // =========================================================
  const HAND_CONNECTIONS = [
    [0,1],[1,2],[2,3],[3,4],
    [0,5],[5,6],[6,7],[7,8],
    [5,9],[9,10],[10,11],[11,12],
    [9,13],[13,14],[14,15],[15,16],
    [13,17],[17,18],[18,19],[19,20],[0,17]
  ];

  function drawHands(results) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!results.multiHandLandmarks) return;

    for (let h = 0; h < results.multiHandLandmarks.length; h++) {
      const landmarks = results.multiHandLandmarks[h];
      const handLabel = results.multiHandedness[h].label; // "Left" or "Right"

      // Determine hand color
      const isLeft = handLabel === 'Left'; // In mirrored view, "Left" is player's right
      const color = isLeft ? 'rgba(255,136,0,0.7)' : 'rgba(123,97,255,0.7)';
      const glow = isLeft ? 'rgba(255,136,0,0.15)' : 'rgba(123,97,255,0.15)';

      // Draw connections
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      for (const [a, b] of HAND_CONNECTIONS) {
        ctx.beginPath();
        ctx.moveTo(landmarks[a].x * canvas.width, landmarks[a].y * canvas.height);
        ctx.lineTo(landmarks[b].x * canvas.width, landmarks[b].y * canvas.height);
        ctx.stroke();
      }

      // Draw landmarks
      for (let i = 0; i < landmarks.length; i++) {
        const x = landmarks[i].x * canvas.width;
        const y = landmarks[i].y * canvas.height;
        const r = i === 0 ? 5 : (i % 4 === 0 ? 4 : 2);
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fillStyle = i === 0 ? color : glow;
        ctx.fill();
      }
    }
  }

  function drawZones() {
    vizCtx.clearRect(0, 0, vizCanvas.width, vizCanvas.height);
    const w = vizCanvas.width;
    const h = vizCanvas.height;
    const now = performance.now();

    for (const zone of DRUM_ZONES) {
      const zx = zone.x1 * w;
      const zy = zone.y1 * h;
      const zw = (zone.x2 - zone.x1) * w;
      const zh = (zone.y2 - zone.y1) * h;

      // Base zone fill
      vizCtx.fillStyle = zone.color + '10'; // very transparent
      vizCtx.fillRect(zx, zy, zw, zh);

      // Zone border
      vizCtx.strokeStyle = zone.color + '30';
      vizCtx.lineWidth = 1;
      vizCtx.strokeRect(zx + 0.5, zy + 0.5, zw - 1, zh - 1);

      // Flash on hit
      const flashTime = zoneFlashes[zone.id];
      if (flashTime) {
        const elapsed = now - flashTime;
        if (elapsed < 300) {
          const alpha = Math.max(0, 0.4 * (1 - elapsed / 300));
          vizCtx.fillStyle = zone.color + Math.round(alpha * 255).toString(16).padStart(2, '0');
          vizCtx.fillRect(zx, zy, zw, zh);
        }
      }

      // Zone label
      vizCtx.fillStyle = zone.color + '80';
      vizCtx.font = '11px "DM Mono", monospace';
      vizCtx.textAlign = 'center';
      vizCtx.textBaseline = 'middle';
      vizCtx.fillText(zone.label, zx + zw / 2, zy + zh / 2);
    }

    // Draw hand position indicators (which zone each hand is in)
    for (const label of ['Left', 'Right']) {
      const state = handTrack[label];
      if (state.zone) {
        const zone = state.zone;
        const zx = zone.x1 * w;
        const zy = zone.y1 * h;
        const zw = (zone.x2 - zone.x1) * w;
        const zh = (zone.y2 - zone.y1) * h;

        vizCtx.strokeStyle = zone.color + '60';
        vizCtx.lineWidth = 2;
        vizCtx.strokeRect(zx + 1, zy + 1, zw - 2, zh - 2);
      }
    }
  }

  // =========================================================
  //  MEDIAPIPE RESULTS HANDLER
  // =========================================================
  function onResults(results) {
    // Resize canvases to match video
    if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
      canvas.width = vizCanvas.width = video.videoWidth;
      canvas.height = vizCanvas.height = video.videoHeight;
    }

    drawHands(results);
    drawZones();

    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
      statusDot.classList.remove('active');
      leftZoneEl.textContent = '—';
      rightZoneEl.textContent = '—';
      // Reset tracking
      handTrack.Left.prevY = null;
      handTrack.Right.prevY = null;
      return;
    }

    statusDot.classList.add('active');

    for (let h = 0; h < results.multiHandLandmarks.length; h++) {
      const landmarks = results.multiHandLandmarks[h];
      const handLabel = results.multiHandedness[h].label; // "Left" or "Right"

      const wrist = landmarks[0];
      // Convert to screen coordinates (mirror X for player perspective)
      const screenX = 1 - wrist.x;
      const screenY = wrist.y;

      // Find which zone the hand is in
      const zone = getZoneAtPosition(screenX, screenY);
      handTrack[handLabel].zone = zone;

      // Update panel display
      // Note: MediaPipe "Left" label = player's right hand (mirrored)
      if (handLabel === 'Left') {
        rightZoneEl.textContent = zone ? zone.label : '—';
      } else {
        leftZoneEl.textContent = zone ? zone.label : '—';
      }

      // Detect strike (using raw wrist.y — downward = increasing Y)
      const hitVelocity = detectStrike(handLabel, wrist.y);

      if (hitVelocity !== null && zone) {
        // Check if hi-hat open/closed
        const isOpenHihat = zone.id === 'hihat' && countExtendedFingers(landmarks) >= 3;

        triggerDrum(zone.id, hitVelocity, isOpenHihat);
      }
    }
  }

  // =========================================================
  //  UI SETUP
  // =========================================================
  function buildKitSelector() {
    kitSelector.innerHTML = '';
    for (const [id, kit] of Object.entries(KITS)) {
      const btn = document.createElement('button');
      btn.className = 'sel-btn' + (id === currentKit ? ' active' : '');
      btn.textContent = kit.name;
      btn.dataset.kit = id;
      btn.onclick = () => loadKit(id);
      kitSelector.appendChild(btn);
    }
  }

  function updateKitButtons() {
    kitSelector.querySelectorAll('.sel-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.kit === currentKit);
    });
  }

  function buildZoneMap() {
    zoneMapEl.innerHTML = '';
    // Top row: crash, splash, ride
    // Mid row: hihat, hi tom, mid tom, floor tom (4 cols → use gridColumn)
    // Bot row: snare, kick

    // Build it as a simple 3-col layout matching the zone arrangement
    const rows = [
      ['crash', 'splash', 'ride'],
      ['hihat', 'tom-hi', 'tom-mid'],
      [null,    null,      'tom-floor'],
      ['snare', 'kick',    null],
    ];

    // Simpler approach: just list all zones
    for (const zone of DRUM_ZONES) {
      const item = document.createElement('div');
      item.className = 'zone-map-item';
      item.textContent = zone.label;
      item.dataset.id = zone.id;
      item.style.borderLeftColor = zone.color;
      item.style.borderLeftWidth = '2px';
      zoneMapEl.appendChild(item);
    }
  }

  // Volume slider
  volumeSlider.addEventListener('input', () => {
    const pct = parseInt(volumeSlider.value);
    masterGain = pct / 100;
    if (gainNode) gainNode.gain.value = masterGain;
    volumePct.textContent = pct + '%';
  });

  // Sensitivity slider
  sensitivitySlider.addEventListener('input', () => {
    const val = parseInt(sensitivitySlider.value);
    sensitivity = val / 1000; // 0.01 to 0.09
    sensitivityVal.textContent = val;
  });

  // =========================================================
  //  START / INIT
  // =========================================================
  async function start() {
    await Tone.start();
    initAudio();
    await loadKit(currentKit);

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
    });

    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.6,
    });

    hands.onResults(onResults);

    const camera = new Camera(video, {
      onFrame: async () => { await hands.send({ image: video }); },
      width: 1280,
      height: 720,
    });

    await camera.start();
    startOverlay.classList.add('hidden');
    statusText.textContent = 'tracking';
    statusDot.classList.add('active');
  }

  startBtn.addEventListener('click', start);

  // Build UI
  buildKitSelector();
  buildZoneMap();

})();
</script>
</body>
</html>
